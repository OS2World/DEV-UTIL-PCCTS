/* sc.h -- string C stack machine macros
 *
 * For use with PCCTS advanced tutorial version 1.0x
 *
 * SOFTWARE RIGHTS
 *
 * We reserve no LEGAL rights to the Purdue Compiler Construction Tool
 * Set (PCCTS) -- PCCTS is in the public domain.  An individual or
 * company may do whatever they wish with source code distributed with
 * PCCTS or the code generated by PCCTS, including the incorporation of
 * PCCTS, or its output, into commerical software.
 * 
 * We encourage users to develop software with PCCTS.  However, we do ask
 * that credit is given to us for developing PCCTS.  By "credit", we
 * mean that if you incorporate our source code into one of your
 * programs (commercial product, research project, or otherwise) that you
 * acknowledge this fact somewhere in the documentation, research report,
 * etc...  If you like PCCTS and have developed a nice tool with the
 * output, please mention that you developed it using PCCTS.  In
 * addition, we ask that this header remain intact in our source code.
 * As long as these guidelines are kept, we expect to continue enhancing
 * this system and expect to make other tools available as they are
 * completed.
 *
 * Terence Parr
 * Purdue University
 * 1989-1992
 */
#include <stdio.h>
#include <ctype.h>
#include <math.h>

/*
 * The function invocation stack looks like:
 *
 *  |	.		|
 *  |	.		|
 *  |	arg		|	fp + 0		arg is "" if none specified
 *  | 1st local	|	fp - 1
 *  | 2nd local	|	fp - 2
 *  |	...		|
 *  |	.		|
 *  |	.		|
 */

#define STR_SIZE		100
#define STK_SIZE		200

/* define stack */
typedef struct { char text[STR_SIZE]; } SCVAR;
static SCVAR stack[STK_SIZE];
static int sp = STK_SIZE, fp;

/* number begins with number or '.' followed by number.  All numbers
 * are converted to floats before comparison.
 */
#define SCnumber(a)	(isdigit(a[0]) || (a[0]=='.' && isdigit(a[1])))

#define TOS			stack[sp].text
#define NTOS		stack[sp+1].text
#define TOSTRUE		((strcmp(TOS, "true")==0)||(strcmp(TOS, "1")==0)		\
					||(SCnumber(TOS)&&atof(TOS)==1.0) )
#define TOSFALSE	((strcmp(TOS, "false")==0)||(strcmp(TOS, "0")==0)		\
					||(SCnumber(TOS)&&atof(TOS)==0.0) )

#define PUSH(a)		{if ( sp==0 ) {fprintf(stderr, "stk ovf!\n"); exit(-1);} \
					strcpy(stack[--sp].text, (a).text);}

#define SPUSH(a)	{if ( sp==0 ) {fprintf(stderr, "stk ovf!\n"); exit(-1);} \
					strcpy(stack[--sp].text, a);}

#define LPUSH(a)	{if ( sp==0 ) {fprintf(stderr, "stk ovf!\n"); exit(-1);} \
					stack[--sp] = stack[fp-a];}

#define CALL(f)		{f();}

#define POP			stack[sp++]

#define LOCAL		{if ( sp==0 ) {fprintf(stderr, "stk ovf!\n"); exit(-1);} \
					stack[--sp].text[0] = '\0';}

#define BRF(lab)	if ( TOSFALSE ) {POP; goto lab;} else POP;
#define BRT(lab)	if ( TOSTRUE ) {POP; goto lab;} else POP;
#define BR(lab)		goto lab

#define PRINT		printf("%s", POP.text)

#define RETURN		{strcpy(stack[fp].text, TOS); END; return;}

#define STORE(v)	{v = POP;}
#define LSTORE(off)	{stack[fp-off] = POP;}

/* operators */

#define EQ			{char *a,*b; float c,d;									\
					a = POP.text; b = POP.text;								\
					if ( SCnumber(a) && SCnumber(b) ) {						\
						c=atof(a); d=atof(b);								\
						if ( c == d ) {SPUSH("true");}						\
					    else SPUSH("false");								\
					}														\
					else if ( strcmp(a, b)==0 ) {SPUSH("true");}			\
					     else SPUSH("false");}
#define NEQ			{SCVAR a,b; float c,d;									\
					a = POP.text; b = POP.text;								\
					if ( SCnumber(a) && SCnumber(b) ) {						\
						c=atof(a); d=atof(b);								\
						if ( c != d ) {SPUSH("true");}						\
					    else SPUSH("false");								\
					}														\
					else if ( strcmp(a, b)!=0 ) {SPUSH("true");}			\
					     else SPUSH("false");}
#define ADD			{SCVAR c; float a,b;									\
					if ( !SCnumber(NTOS) || !SCnumber(TOS) ) { 				\
						strncat(NTOS, TOS, STR_SIZE - strlen(NTOS));		\
						sp++;												\
					} else {												\
						a=atof(POP.text); b=atof(POP.text);					\
						sprintf(c.text, "%f", a+b); PUSH(c);				\
					}}
#define SUB			{SCVAR c; float a,b; a=atof(POP.text); b=atof(POP.text); \
					sprintf(c.text, "%f", b-a); PUSH(c);}
#define MUL			{SCVAR c; float a,b; a=atof(POP.text); b=atof(POP.text); \
					sprintf(c.text, "%f", a*b); PUSH(c);}
#define DIV			{SCVAR c; float a,b; a=atof(POP.text); b=atof(POP.text); \
					sprintf(c.text, "%f", b/a); PUSH(c);}
#define NEG			{SCVAR c; float a; a=atof(POP.text); \
					sprintf(c.text, "%f", -a); PUSH(c);}
#define DUP			{if ( sp==0 ) {fprintf(stderr, "stk ovf!\n"); exit(-1);} \
					stack[sp-1] = stack[sp]; --sp;}

#define BEGIN		int save_fp = fp; fp = sp
#define END			sp = fp; fp = save_fp;

main(argc, argv)
int argc;
char *argv[];
{
	if ( argc == 2 ) {SPUSH(argv[1]);}
	else SPUSH("");
	CALL(_main);
	POP;
}
